#!/bin/bash -e

. "$HOME/dotfiles/bin/dffunc"

name=$(git config --global user.name)
jsonurl=http://noyuno.mydns.jp/data/repo.json
outtmp=$DFTMP/out
if [ "$1" ]; then
    base="$1"
else
    base="$HOME"
fi

_check_url()
{
    name=$1
    remote_name=$2
    remote_url=$3
    matched=
    while read line; do
        rname=$(echo $line | cut -d ' ' -f 1)
        rurl=$(echo $line | cut -d ' ' -f 2)
        if [ "$rname" = "$remote_name" ]; then
            matched=1
            if [ "$rurl" != "$remote_url" ]; then
                echo -e "\e[33m[ change remote ]\e[m $name($remote_name) to $remote_url"
                git remote set-url "$remote_name" "$remote_url"
            fi
        fi
    done
    if [ ! "$matched" ]; then
        echo -e "\e[33m[ add remote ]\e[m $name($remote_name) to $remote_url"
        git remote add "$remote_name" "$remote_url"
    fi
}

_check_remote()
{
    name=$1
    remote_name=$2
    remote_url=$3
    git remote -v | _check_url $name $remote_name $remote_url
}

_update_repo()
{
    name=$1
    remote_name=$2
    remote_url=$3
    dirty=$4
    if [ -d "$base/$name/.git" ]; then
        pushd "$base/$name" >/dev/null
        _check_remote  "$name" "$remote_name" "$remote_url"
        if [ "$dirty" ]; then
            ret=$(git -c color.status=always fetch $remote_name)
            if [ ! "$ret" = "" ]; then
                echo "$ret"
                return 3
            fi
        else
            ret=$(git -c color.status=always pull $remote_name master 2>$DFTMP/git-pull-stderr-$name-$remote_name)
            echo "$ret" | grep '^Already up-to-date.$' >/dev/null 2>&1 &&:
            if [ $? -eq 0 ]; then
                # did update local branch?
                localhead=$(git branch -va --no-color | awk '/^*/{print $3}')
                remotehead=$(git branch -va --no-color | awk '/remotes\/'$remote_name'\/master/{print $2}')
                if [ "$localhead" = "$remotehead" ]; then
                    return 0
                else
                    return 4
                fi
            else
                cat $DFTMP/git-pull-stderr-$name-$remote_name
                echo "$ret"
                return 2
            fi
        fi
        popd >/dev/null
    else
        git clone "$remote_url" "$base/$name"
        return 1
    fi
}

_check_dirty()
{
    name=$1
    if [ -d "$base/$name/.git" ]; then
        pushd "$base/$name" >/dev/null
        status=$(git status -s)
        if [ "$status" ]; then
            echo -e "\e[33m[ dirty ] $name\e[m ($(echo "$status" | wc -l) files)"
            git -c color.status=always status -s
            return 0
        fi
        popd >/dev/null
    fi
    return 1
}

update_repo()
{
    len=$(jq -r length "$json")
    for i in $(seq 0 $((len - 1))); do
        (
        name=$(jq -r '.['$i'].name' "$json")
        remotelen=$(jq -r '.['$i'].remote | length' "$json")
        dirty=
        if _check_dirty $name ; then
            dirty=1
        fi
        latest=
        declare -A remote_status
        for j in $(seq 0 $((remotelen - 1))); do
            remote_name=$(jq -r '.['$i'].remote['$j'].name' $json)
            remote_url=$(jq -r '.['$i'].remote['$j'].url' $json)
            _update_repo "$name" "$remote_name" "$remote_url" "$dirty" &&:
            case "$?" in
                0) # latest
                    remote_status[$remote_name]="latest "
                    ;;
                1) # clone
                    remote_status[$remote_name]="\e[32mclone  \e[m"
                    ;;
                2) # pull
                    remote_status[$remote_name]="\e[34mpull   \e[m"
                    ;;
                3) # fetch
                    remote_status[$remote_name]="\e[35mfetch  \e[m"
                    ;;
                4) # forward
                    remote_status[$remote_name]="\e[33mforward\e[m"
                    ;;
            esac
        done
        if [ "$dirty" ]; then
            dirty_message="\e[31mdirty\e[m"
        else
            dirty_message="     "
        fi
        printf "%-20s " "$name" >> $outtmp
        echo -ne "$dirty_message " >> $outtmp
        for k in "${!remote_status[@]}"; do
            echo -ne "$k:${remote_status[$k]} " >> $outtmp
        done
        echo "" >> $outtmp
        echo -ne "\e[2K\e[1Gprocessed $name ($((i+1)) of $len)"
        ) &
    done
}

# pi
json="$DFTMP/repo.json"
curl -sL "$jsonurl" > "$DFTMP/repo.json"
update_repo

wait

echo -ne "\e[2K\e[1G"
cat $outtmp | sort

finalize

