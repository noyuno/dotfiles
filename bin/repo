#!/bin/bash -e

. "$HOME/dotfiles/bin/dffunc"

name=$(git config --global user.name)

_check_url()
{
    name=$1
    remote_name=$2
    remote_url=$3
    matched=
    while read line; do
        rname=$(echo $line | cut -d ' ' -f 1)
        rurl=$(echo $line | cut -d ' ' -f 2)
        if [ "$rname" = "$remote_name" ]; then
            matched=1
            if [ "$rurl" != "$remote_url" ]; then
                echo -e "\e[33m[ change remote ]\e[m $name/$remote_name to $remote_url"
                git remote set-url "$remote_name" "$remote_url"
            fi
        fi
    done
    if [ ! "$matched" ]; then
        echo -e "\e[33m[ add remote ]\e[m $name/$remote_name to $remote_url"
        git remote add "$remote_name" "$remote_url"
    fi
}

_check_remote()
{
    name=$1
    remote_name=$2
    remote_url=$3
    git remote -v | _check_url $name $remote_name $remote_url
}

_check_repo()
{
    name=$1
    remote_name=$2
    remote_url=$3
    if [ -d "$HOME/$name/.git" ]; then
        pushd "$HOME/$name" >/dev/null
        _check_remote  "$name" "$remote_name" "$remote_url"
        status=$(git status -s)
        if [ "$status" ]; then
            echo -e "\e[33m[ dirty   ] $name\e[m"
            git -c color.status=always status -s | \
                awk '{print "  "$1"         '$name/'"$2}' 
            ret=$(git fetch $remote_name)
            if [ ! "$ret" = "" ]; then
                echo -e "\e[32m[ fetch   ] $name\e[m"
                echo "$ret"
            fi
        else
            ret=$(git pull $remote_name master)
            if [ "$ret" = "Already up-to-date." ]; then
                # did update local branch?
                localhead=$(git branch -va --no-color | awk '/^*/{print $3}')
                remotehead=$(git branch -va --no-color | awk '/remotes\/origin\/master/{print $2}')
                if [ "$localhead" = "$remotehead" ]; then
                    echo "[ latest  ] $name"
                else
                    echo -e "\e[33m[ forward ] $name\e[m"
                fi
            else
                echo -e "\e[32m[ pull    ] $name\e[m"
                echo "$ret"
            fi
        fi
        popd >/dev/null
    else
        echo -e "\e[32m[ clone   ] $name\e[m"
        git clone "$remote_url" "$HOME/$name"
    fi
}

check_repo()
{
    len=$(jq -r length "$json")
    for i in $(seq 0 $((len - 1))); do
        name=$(jq -r '.['$i'].name' "$json")
        remotelen=$(jq -r '.['$i'].remote | length' "$json")
        (
        for j in $(seq 0 $((remotelen - 1))); do
            remote_name=$(jq -r '.['$i'].remote['$j'].name' $json)
            remote_url=$(jq -r '.['$i'].remote['$j'].url' $json)
            _check_repo "$name" "$remote_name" "$remote_url"
        done
        ) &
    done
}

# pi
json="$DFTMP/repo.json"
curl -sL http://noyuno.mydns.jp/data/repo.json > "$DFTMP/repo.json"
check_repo

wait

finalize

